{"version":3,"sources":["../../src/server/generateHTML.ts","../../src/server/getHTMLFromFragment.ts","../../src/server/generateJSON.ts"],"sourcesContent":["import { type Extensions, type JSONContent, getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * This function generates HTML from a ProseMirror JSON content object.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * ```js\n * const html = generateHTML(doc, extensions)\n * console.log(html)\n * ```\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  if (typeof window !== 'undefined') {\n    throw new Error(\n      'generateHTML can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns A promise containing the HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const localWindow = new Window()\n\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n    document: localWindow.document as unknown as Document,\n  })\n\n  const serializer = new localWindow.XMLSerializer()\n\n  return serializer.serializeToString(fragment as any)\n}\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { type ParseOptions, DOMParser as PMDOMParser } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Promise<Record<string, any>>} - A promise with the generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  if (typeof window !== 'undefined') {\n    throw new Error(\n      'generateJSON can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const localWindow = new Window()\n  const localDOMParser = new localWindow.DOMParser()\n\n  const schema = getSchema(extensions)\n  let doc: ReturnType<typeof localDOMParser.parseFromString> | null = null\n\n  const htmlString = `<!DOCTYPE html><html><body>${html}</body></html>`\n  doc = localDOMParser.parseFromString(htmlString, 'text/html')\n\n  if (!doc) {\n    throw new Error('Failed to parse HTML string')\n  }\n\n  return PMDOMParser.fromSchema(schema)\n    .parse(doc.body as unknown as Node, options)\n    .toJSON()\n}\n"],"mappings":";AAAA,SAA4C,iBAAiB;AAC7D,SAAS,YAAY;;;ACArB,SAAS,qBAAqB;AAC9B,SAAS,cAAc;AAehB,SAAS,oBAAoB,KAAW,QAAgB,SAA2C;AACxG,MAAI,mCAAS,UAAU;AACrB,UAAM,OAAO,QAAQ,SAAS,cAAc,KAAK;AAEjD,kBAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS,EAAE,UAAU,QAAQ,SAAS,GAAG,IAAI;AACpG,WAAO,KAAK;AAAA,EACd;AAEA,QAAM,cAAc,IAAI,OAAO;AAE/B,QAAM,WAAW,cAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS;AAAA,IAC/E,UAAU,YAAY;AAAA,EACxB,CAAC;AAED,QAAM,aAAa,IAAI,YAAY,cAAc;AAEjD,SAAO,WAAW,kBAAkB,QAAe;AACrD;;;ADhBO,SAAS,aAAa,KAAkB,YAAgC;AAC7E,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,UAAU,UAAU;AACnC,QAAM,cAAc,KAAK,SAAS,QAAQ,GAAG;AAE7C,SAAO,oBAAoB,aAAa,MAAM;AAChD;;;AE5BA,SAAS,aAAAA,kBAAiB;AAC1B,SAA4B,aAAa,mBAAmB;AAC5D,SAAS,UAAAC,eAAc;AAehB,SAAS,aAAa,MAAc,YAAwB,SAA6C;AAC9G,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc,IAAIA,QAAO;AAC/B,QAAM,iBAAiB,IAAI,YAAY,UAAU;AAEjD,QAAM,SAASD,WAAU,UAAU;AACnC,MAAI,MAAgE;AAEpE,QAAM,aAAa,8BAA8B,IAAI;AACrD,QAAM,eAAe,gBAAgB,YAAY,WAAW;AAE5D,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM,6BAA6B;AAAA,EAC/C;AAEA,SAAO,YAAY,WAAW,MAAM,EACjC,MAAM,IAAI,MAAyB,OAAO,EAC1C,OAAO;AACZ;","names":["getSchema","Window"]}