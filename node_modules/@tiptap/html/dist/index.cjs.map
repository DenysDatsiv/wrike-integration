{"version":3,"sources":["/home/runner/work/tiptap/tiptap/packages/html/dist/index.cjs","../src/generateHTML.ts","../src/getHTMLFromFragment.ts","../src/generateJSON.ts"],"names":["getSchema"],"mappings":"AAAA;ACCA,oCAA0B;AAC1B,yCAAqB;ADCrB;AACA;AEHA;AAcO,SAAS,mBAAA,CAAoB,GAAA,EAAW,MAAA,EAAgB,OAAA,EAA2C;AACxG,EAAA,GAAA,CAAI,OAAO,OAAA,IAAW,WAAA,EAAa;AACjC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,EACF;AAEA,EAAA,GAAA,CAAI,QAAA,GAAA,KAAA,EAAA,KAAA,EAAA,EAAA,OAAA,CAAS,QAAA,EAAU;AACrB,IAAA,MAAM,KAAA,EAAO,OAAA,CAAQ,QAAA,CAAS,aAAA,CAAc,KAAK,CAAA;AAEjD,IAAA,oBAAA,CAAc,UAAA,CAAW,MAAM,CAAA,CAAE,iBAAA,CAAkB,GAAA,CAAI,OAAA,EAAS,EAAE,QAAA,EAAU,OAAA,CAAQ,SAAS,CAAA,EAAG,IAAI,CAAA;AACpG,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAEA,EAAA,MAAM,SAAA,EAAW,oBAAA,CAAc,UAAA,CAAW,MAAM,CAAA,CAAE,iBAAA,CAAkB,GAAA,CAAI,OAAA,EAAS;AAAA,IAC/E,QAAA,EAAU,MAAA,CAAO;AAAA,EACnB,CAAC,CAAA;AAED,EAAA,MAAM,WAAA,EAAa,IAAI,aAAA,CAAc,CAAA;AAErC,EAAA,OAAO,UAAA,CAAW,iBAAA,CAAkB,QAAe,CAAA;AACrD;AFbA;AACA;ACKO,SAAS,YAAA,CAAa,GAAA,EAAkB,UAAA,EAAgC;AAC7E,EAAA,GAAA,CAAI,OAAO,OAAA,IAAW,WAAA,EAAa;AACjC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,EACF;AAEA,EAAA,MAAM,OAAA,EAAS,6BAAA,UAAoB,CAAA;AACnC,EAAA,MAAM,YAAA,EAAc,WAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,GAAG,CAAA;AAE7C,EAAA,OAAO,mBAAA,CAAoB,WAAA,EAAa,MAAM,CAAA;AAChD;ADLA;AACA;AGnCA;AAEA;AAcO,SAAS,YAAA,CAAa,IAAA,EAAc,UAAA,EAAwB,OAAA,EAA6C;AAC9G,EAAA,GAAA,CAAI,OAAO,OAAA,IAAW,WAAA,EAAa;AACjC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,EACF;AAEA,EAAA,MAAM,OAAA,EAASA,6BAAAA,UAAoB,CAAA;AACnC,EAAA,MAAM,IAAA,EAAgB,IAAI,MAAA,CAAO,SAAA,CAAU,CAAA,CAAE,eAAA,CAAgB,IAAA,EAAM,WAAW,CAAA;AAE9E,EAAA,GAAA,CAAI,CAAC,GAAA,EAAK;AACR,IAAA,MAAM,IAAI,KAAA,CAAM,6BAA6B,CAAA;AAAA,EAC/C;AAEA,EAAA,OAAO,gBAAA,CAAU,UAAA,CAAW,MAAM,CAAA,CAC/B,KAAA,CAAM,GAAA,CAAI,IAAA,EAAc,OAAO,CAAA,CAC/B,MAAA,CAAO,CAAA;AACZ;AHkBA;AACE;AACA;AACF,yEAAC","file":"/home/runner/work/tiptap/tiptap/packages/html/dist/index.cjs","sourcesContent":[null,"import type { Extensions, JSONContent } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * Generates HTML from a ProseMirror JSON content object.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * const doc = {\n *   type: 'doc',\n *   content: [\n *     {\n *       type: 'paragraph',\n *       content: [\n *         {\n *           type: 'text',\n *           text: 'Hello world!'\n *         }\n *       ]\n *     }\n *   ]\n * }\n * const extensions = [...]\n * const html = generateHTML(doc, extensions)\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateHTML can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns The HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'getHTMLFromFragment can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n    document: window.document as unknown as Document,\n  })\n\n  const serializer = new XMLSerializer()\n\n  return serializer.serializeToString(fragment as any)\n}\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport type { ParseOptions } from '@tiptap/pm/model'\nimport { DOMParser } from '@tiptap/pm/model'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Record<string, any>} - The generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateJSON can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const doc: Document = new window.DOMParser().parseFromString(html, 'text/html')\n\n  if (!doc) {\n    throw new Error('Failed to parse HTML string')\n  }\n\n  return DOMParser.fromSchema(schema)\n    .parse(doc.body as Node, options)\n    .toJSON()\n}\n"]}