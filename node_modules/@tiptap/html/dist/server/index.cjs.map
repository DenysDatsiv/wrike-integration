{"version":3,"sources":["/home/runner/work/tiptap/tiptap/packages/html/dist/server/index.cjs","../../src/server/generateHTML.ts","../../src/server/getHTMLFromFragment.ts","../../src/server/generateJSON.ts"],"names":["Window","getSchema"],"mappings":"AAAA;ACAA,oCAA6D;AAC7D,yCAAqB;ADErB;AACA;AEHA;AACA,qCAAuB;AAehB,SAAS,mBAAA,CAAoB,GAAA,EAAW,MAAA,EAAgB,OAAA,EAA2C;AACxG,EAAA,GAAA,CAAI,QAAA,GAAA,KAAA,EAAA,KAAA,EAAA,EAAA,OAAA,CAAS,QAAA,EAAU;AACrB,IAAA,MAAM,KAAA,EAAO,OAAA,CAAQ,QAAA,CAAS,aAAA,CAAc,KAAK,CAAA;AAEjD,IAAA,oBAAA,CAAc,UAAA,CAAW,MAAM,CAAA,CAAE,iBAAA,CAAkB,GAAA,CAAI,OAAA,EAAS,EAAE,QAAA,EAAU,OAAA,CAAQ,SAAS,CAAA,EAAG,IAAI,CAAA;AACpG,IAAA,OAAO,IAAA,CAAK,SAAA;AAAA,EACd;AAEA,EAAA,MAAM,YAAA,EAAc,IAAI,qBAAA,CAAO,CAAA;AAE/B,EAAA,MAAM,SAAA,EAAW,oBAAA,CAAc,UAAA,CAAW,MAAM,CAAA,CAAE,iBAAA,CAAkB,GAAA,CAAI,OAAA,EAAS;AAAA,IAC/E,QAAA,EAAU,WAAA,CAAY;AAAA,EACxB,CAAC,CAAA;AAED,EAAA,MAAM,WAAA,EAAa,IAAI,WAAA,CAAY,aAAA,CAAc,CAAA;AAEjD,EAAA,OAAO,UAAA,CAAW,iBAAA,CAAkB,QAAe,CAAA;AACrD;AFdA;AACA;ACHO,SAAS,YAAA,CAAa,GAAA,EAAkB,UAAA,EAAgC;AAC7E,EAAA,GAAA,CAAI,OAAO,OAAA,IAAW,WAAA,EAAa;AACjC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,EACF;AAEA,EAAA,MAAM,OAAA,EAAS,6BAAA,UAAoB,CAAA;AACnC,EAAA,MAAM,YAAA,EAAc,WAAA,CAAK,QAAA,CAAS,MAAA,EAAQ,GAAG,CAAA;AAE7C,EAAA,OAAO,mBAAA,CAAoB,WAAA,EAAa,MAAM,CAAA;AAChD;ADGA;AACA;AGhCA;AACA;AACA;AAeO,SAAS,YAAA,CAAa,IAAA,EAAc,UAAA,EAAwB,OAAA,EAA6C;AAC9G,EAAA,GAAA,CAAI,OAAO,OAAA,IAAW,WAAA,EAAa;AACjC,IAAA,MAAM,IAAI,KAAA;AAAA,MACR;AAAA,IACF,CAAA;AAAA,EACF;AAEA,EAAA,MAAM,YAAA,EAAc,IAAIA,qBAAAA,CAAO,CAAA;AAC/B,EAAA,MAAM,eAAA,EAAiB,IAAI,WAAA,CAAY,SAAA,CAAU,CAAA;AAEjD,EAAA,MAAM,OAAA,EAASC,6BAAAA,UAAoB,CAAA;AACnC,EAAA,IAAI,IAAA,EAAgE,IAAA;AAEpE,EAAA,MAAM,WAAA,EAAa,CAAA,2BAAA,EAA8B,IAAI,CAAA,cAAA,CAAA;AACrD,EAAA,IAAA,EAAM,cAAA,CAAe,eAAA,CAAgB,UAAA,EAAY,WAAW,CAAA;AAE5D,EAAA,GAAA,CAAI,CAAC,GAAA,EAAK;AACR,IAAA,MAAM,IAAI,KAAA,CAAM,6BAA6B,CAAA;AAAA,EAC/C;AAEA,EAAA,OAAO,gBAAA,CAAY,UAAA,CAAW,MAAM,CAAA,CACjC,KAAA,CAAM,GAAA,CAAI,IAAA,EAAyB,OAAO,CAAA,CAC1C,MAAA,CAAO,CAAA;AACZ;AHaA;AACE;AACA;AACF,yEAAC","file":"/home/runner/work/tiptap/tiptap/packages/html/dist/server/index.cjs","sourcesContent":[null,"import { type Extensions, type JSONContent, getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * This function generates HTML from a ProseMirror JSON content object.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * ```js\n * const html = generateHTML(doc, extensions)\n * console.log(html)\n * ```\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  if (typeof window !== 'undefined') {\n    throw new Error(\n      'generateHTML can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns A promise containing the HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const localWindow = new Window()\n\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n    document: localWindow.document as unknown as Document,\n  })\n\n  const serializer = new localWindow.XMLSerializer()\n\n  return serializer.serializeToString(fragment as any)\n}\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { type ParseOptions, DOMParser as PMDOMParser } from '@tiptap/pm/model'\nimport { Window } from 'happy-dom'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @remarks **Important**: This function requires `happy-dom` to be installed in your project.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Promise<Record<string, any>>} - A promise with the generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  if (typeof window !== 'undefined') {\n    throw new Error(\n      'generateJSON can only be used in a Node environment\\nIf you want to use this in a browser environment, use the `@tiptap/html` import instead.',\n    )\n  }\n\n  const localWindow = new Window()\n  const localDOMParser = new localWindow.DOMParser()\n\n  const schema = getSchema(extensions)\n  let doc: ReturnType<typeof localDOMParser.parseFromString> | null = null\n\n  const htmlString = `<!DOCTYPE html><html><body>${html}</body></html>`\n  doc = localDOMParser.parseFromString(htmlString, 'text/html')\n\n  if (!doc) {\n    throw new Error('Failed to parse HTML string')\n  }\n\n  return PMDOMParser.fromSchema(schema)\n    .parse(doc.body as unknown as Node, options)\n    .toJSON()\n}\n"]}