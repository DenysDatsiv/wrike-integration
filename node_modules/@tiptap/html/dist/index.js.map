{"version":3,"sources":["../src/generateHTML.ts","../src/getHTMLFromFragment.ts","../src/generateJSON.ts"],"sourcesContent":["import type { Extensions, JSONContent } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport { Node } from '@tiptap/pm/model'\n\nimport { getHTMLFromFragment } from './getHTMLFromFragment.js'\n\n/**\n * Generates HTML from a ProseMirror JSON content object.\n * @param doc - The ProseMirror JSON content object.\n * @param extensions - The Tiptap extensions used to build the schema.\n * @returns The generated HTML string.\n * @example\n * const doc = {\n *   type: 'doc',\n *   content: [\n *     {\n *       type: 'paragraph',\n *       content: [\n *         {\n *           type: 'text',\n *           text: 'Hello world!'\n *         }\n *       ]\n *     }\n *   ]\n * }\n * const extensions = [...]\n * const html = generateHTML(doc, extensions)\n */\nexport function generateHTML(doc: JSONContent, extensions: Extensions): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateHTML can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const contentNode = Node.fromJSON(schema, doc)\n\n  return getHTMLFromFragment(contentNode, schema)\n}\n","import type { Node, Schema } from '@tiptap/pm/model'\nimport { DOMSerializer } from '@tiptap/pm/model'\n\n/**\n * Returns the HTML string representation of a given document node.\n *\n * @param doc - The document node to serialize.\n * @param schema - The Prosemirror schema to use for serialization.\n * @returns The HTML string representation of the document fragment.\n *\n * @example\n * ```typescript\n * const html = getHTMLFromFragment(doc, schema)\n * ```\n */\nexport function getHTMLFromFragment(doc: Node, schema: Schema, options?: { document?: Document }): string {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'getHTMLFromFragment can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  if (options?.document) {\n    const wrap = options.document.createElement('div')\n\n    DOMSerializer.fromSchema(schema).serializeFragment(doc.content, { document: options.document }, wrap)\n    return wrap.innerHTML\n  }\n\n  const fragment = DOMSerializer.fromSchema(schema).serializeFragment(doc.content, {\n    document: window.document as unknown as Document,\n  })\n\n  const serializer = new XMLSerializer()\n\n  return serializer.serializeToString(fragment as any)\n}\n","import type { Extensions } from '@tiptap/core'\nimport { getSchema } from '@tiptap/core'\nimport type { ParseOptions } from '@tiptap/pm/model'\nimport { DOMParser } from '@tiptap/pm/model'\n\n/**\n * Generates a JSON object from the given HTML string and converts it into a Prosemirror node with content.\n * @param {string} html - The HTML string to be converted into a Prosemirror node.\n * @param {Extensions} extensions - The extensions to be used for generating the schema.\n * @param {ParseOptions} options - The options to be supplied to the parser.\n * @returns {Record<string, any>} - The generated JSON object.\n * @example\n * const html = '<p>Hello, world!</p>'\n * const extensions = [...]\n * const json = generateJSON(html, extensions)\n * console.log(json) // { type: 'doc', content: [{ type: 'paragraph', content: [{ type: 'text', text: 'Hello, world!' }] }] }\n */\nexport function generateJSON(html: string, extensions: Extensions, options?: ParseOptions): Record<string, any> {\n  if (typeof window === 'undefined') {\n    throw new Error(\n      'generateJSON can only be used in a browser environment\\nIf you want to use this in a Node environment, use the `@tiptap/html/server` import instead.',\n    )\n  }\n\n  const schema = getSchema(extensions)\n  const doc: Document = new window.DOMParser().parseFromString(html, 'text/html')\n\n  if (!doc) {\n    throw new Error('Failed to parse HTML string')\n  }\n\n  return DOMParser.fromSchema(schema)\n    .parse(doc.body as Node, options)\n    .toJSON()\n}\n"],"mappings":";AACA,SAAS,iBAAiB;AAC1B,SAAS,YAAY;;;ACDrB,SAAS,qBAAqB;AAcvB,SAAS,oBAAoB,KAAW,QAAgB,SAA2C;AACxG,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,MAAI,mCAAS,UAAU;AACrB,UAAM,OAAO,QAAQ,SAAS,cAAc,KAAK;AAEjD,kBAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS,EAAE,UAAU,QAAQ,SAAS,GAAG,IAAI;AACpG,WAAO,KAAK;AAAA,EACd;AAEA,QAAM,WAAW,cAAc,WAAW,MAAM,EAAE,kBAAkB,IAAI,SAAS;AAAA,IAC/E,UAAU,OAAO;AAAA,EACnB,CAAC;AAED,QAAM,aAAa,IAAI,cAAc;AAErC,SAAO,WAAW,kBAAkB,QAAe;AACrD;;;ADPO,SAAS,aAAa,KAAkB,YAAgC;AAC7E,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,UAAU,UAAU;AACnC,QAAM,cAAc,KAAK,SAAS,QAAQ,GAAG;AAE7C,SAAO,oBAAoB,aAAa,MAAM;AAChD;;;AEvCA,SAAS,aAAAA,kBAAiB;AAE1B,SAAS,iBAAiB;AAcnB,SAAS,aAAa,MAAc,YAAwB,SAA6C;AAC9G,MAAI,OAAO,WAAW,aAAa;AACjC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAASA,WAAU,UAAU;AACnC,QAAM,MAAgB,IAAI,OAAO,UAAU,EAAE,gBAAgB,MAAM,WAAW;AAE9E,MAAI,CAAC,KAAK;AACR,UAAM,IAAI,MAAM,6BAA6B;AAAA,EAC/C;AAEA,SAAO,UAAU,WAAW,MAAM,EAC/B,MAAM,IAAI,MAAc,OAAO,EAC/B,OAAO;AACZ;","names":["getSchema"]}